%%=======================================================================%  jointhist: function for computing a joint histogram between two images% =======================================================================%  Bart Goossens%  Department of Telecommunications and Information Processing% =======================================================================%%  ARGUMENTS:%  - g_x: image for the x-axis%  - g_y: image for the y-axis%  - M:   points on the X axis [optional, default=256]%  - N:   points on the Y axis [optional, default=256]%  - channel: color channel to display (R=1, G=2, B=3)%%  EXAMPLE: run this script with no arguments (press F5)%function [g_hist,range]=jointhist(g_x,g_y,M,N,channel)% no arguments provided: run the exampleif nargin==0    x = double(imread('cameraman.tif'));          % gamma correction + noise    y = ((x/255).^0.4)*255 + 10*randn(size(x));        z = jointhist(x,y);    z = 255*((z-min(min(z)))/(max(max(z))-min(min(z)))).^0.1;    figure,imagesc(z),colormap(1-gray);%     curve_x = 1:255;%     curve_y = ((curve_x/255).^0.4)*255;%     hold on,plot(curve_x,257-curve_y,'r','LineWidth',3);%     xlabel('Genormaliseerde pixelintensiteit in beeld 1');%     ylabel('Genormaliseerde pixelintensiteit in beeld 2');    %xlim([10 255]);    return;end;if nargin<3    M=1:256;    N=1:256;    channel=2; % green channel by defaultend;if size(g_x) ~= size(g_y),    error 'g_x and g_y should have the same dimensions!'end;% a colour image is providedif ndims(g_x) == 3,    g_x=g_x(:,:,channel);    g_y=g_y(:,:,channel);        end;% automatic rangeif length(M)==1 && length(N)==1,    g_x_min = min(min(g_x));    g_y_min = min(min(g_y));    g_x = g_x - g_x_min;    g_y = g_y - g_y_min;    g_y_max=ceil(max(max(g_y)));    g_x_max=ceil(max(max(g_x)));    else    g_x_min=N(1);    g_x_max=N(end);    g_y_min=M(1);    g_y_max=M(end);    g_x = g_x - g_x_min;    g_y = g_y - g_y_min;    M=length(M); N=length(N);end;g_hist=zeros(M,N);sc_y = M/(g_y_max);sc_x = N/(g_x_max);g_x = max(min(floor(1+g_x*sc_x),N),1);g_y = max(min(M+1-floor(g_y*sc_y),M),1);for m=1:size(g_x,1),    for n=1:size(g_x,2),        x=g_x(m,n);        y=g_y(m,n);        g_hist(y,x)=g_hist(y,x)+1;    end;end;    g_hist=g_hist./(ones(size(g_hist,1),1)*max(1,sum(g_hist,1)));range=[g_y_min  g_y_max; ...       g_x_min  g_x_max];